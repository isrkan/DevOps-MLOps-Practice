# Specifies the version of the Docker Compose file format
version: '3.8'

# Defines the services that make up the application
# Each service represents a container that will be managed by Docker Compose
services:
  # The name of the service. This identifier is used when referencing this service in other configurations or during container management
  django-app:
    # Specifies the build context for the Django application. It determines how the Docker image for this service is built
    build: 
      # Specifies the directory containing the Dockerfile and other necessary files
      context: .
      # Dockerfile specifies the name of the Dockerfile to use. This is optional if the file is named Dockerfile
      dockerfile: Dockerfile
    # Exposes port 8000 on the container and maps it to port 8000 on the host machine
    ports:
      - "8000:8000"
    # Mounts the current directory (where the Docker Compose file is located) as a volume in the container
    # This ensures that any changes made to the application code on the host are immediately reflected in the container. This is particularly useful in a development environment
    volumes:
      - .:/app
    # Sets environment variables for the Django application, used to configure the Django app's behavior
    environment:
        # Specifies the settings module for the Django application
      - DJANGO_SETTINGS_MODULE=myproject.settings
        # Specifies the environment in which the Django application is running (development, production, etc)
      - DJANGO_ENV=development
        # Specifies the database URL for Django to connect to the PostgreSQL database
      - DATABASE_URL=postgresql://user:password@db:5432/mydatabase
    # Dependencies: Ensures that this service starts only after the specified services are running
    depends_on:
      - db
    # Overrides the default command specified in the Dockerfile
    command: ["python", "manage.py", "runserver", "0.0.0.0:8000"]
    # Set restart policy - automatically restart the container if it stops
    # The unless-stopped policy means the container will be restarted unless it is explicitly stopped by the user
    restart: unless-stopped
    # Limits the amount of memory and CPU available to the container
    deploy:
      resources:
        limits:
          cpus: '0.50'
          memory: '512M'
    # Defines a command to check the health of the container
    healthcheck:
      # The health check uses curl to make an HTTP request to the Django application's health endpoint
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      # Time between running the health check
      interval: 30s
      # Time to wait for the health check to complete
      timeout: 10s
      # Number of times to retry the health check before considering the container unhealthy
      retries: 3
    # Configures the logging options for the service
    logging:
      # The json-file driver is used, with options to limit the log file size and the number of log files
      driver: "json-file"
      options:
        max-size: "10m"  # Maximum size of each log file
        max-file: "3"  # Maximum number of log files to keep

  # The database service, using PostgreSQL as an example
  db:
    # Uses the official PostgreSQL image from Docker Hub
    image: postgres:13
    # Exposes port 5432 on the container and maps it to port 5432 on the host machine
    ports:
      - "5432:5432"
    # Sets environment variables for the PostgreSQL container
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=mydatabase
    # Named volumes can be used to persist data between container restarts. The db_data volume is used to store PostgreSQL data
    volumes:
      - db_data:/var/lib/postgresql/data

# Defines named volumes that can be shared across multiple services
# Named volumes persist data outside the lifecycle of a specific container, allowing data to survive container restarts and re-creation
volumes:
  db_data: